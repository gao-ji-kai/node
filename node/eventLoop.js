
/**
    事件循环
         1.进程:是系统进行资源分配的最小单位, (每个进程是独立的、可以有多个进程 进程之间也可以进行通信,从而实现交互)
            进程中至少有一个线程(主线程),进程中的多个线程可以同时运行

                浏览器是多进程的,每个页面都是一个进程,每个进程中都有一个主线程
                    浏览器的组成
                        浏览器的主进程：负责界面显示、用户交互、子进程管理，同时提供存储等功能
                        网络进程：负责页面的网络资源加载
                        插件进程：负责插件的运行
                        GPU进程:处理图形
                        渲染进程：核心进程，负责一个Tab内的页面渲染，脚本执行，事件处理等(每个页面都有一个自己的渲染进程)
         2.线程:是进程中的一个执行单元,负责当前进程中程序的执行
                    js是单线程的,js引擎只有一个线程,js中的异步是通过事件循环机制实现的 (主线程只有一个,js引擎只有一个,所以js是单线程的)
                        运行js引擎线程时不能执行渲染线程 渲染线程也不能执行js引擎线程(互斥)
                    web worker:是浏览器中的另外一个线程,可以通过js代码创建,可以执行一些耗时的操作,但是不能操作DOM,也不能操作DOM BOM
                    网络线程:负责页面的网络资源加载 (ajax)
                    事件触发线程(Event Loop):负责页面的事件处理(事件绑定,事件回调) 调度异步任务的
                        事件循环:是js实现异步的一种机制,js中的任务分为同步任务和异步任务,同步任务都在主线程上执行,形成一个执行栈,异步任务有了结果后,将回调函数放入任务队列中,任务队列只有在主线程空闲的时候才会将队列中的任务放入主线程中执行
                        事件循环的顺序:先执行同步代码,再执行微任务队列,再执行宏任务队列
                        定时器线程:负责定时器的执行
         3.任务队列分为宏任务队列和微任务队列
                    宏任务队列:包括整体代码script(脚本执行),setTimeout,setInterval,请求,事件,messageChannel,I/O UI交互
                    微任务队列:Promise.then,process.nextTick(只在node中有),MutationObserver(只在浏览器中有),queueMicrotask(只在浏览器中有)
                    
                    执行顺序 默认会拿出一个宏任务来执行，宏任务执行时 会产生微任务 当宏任务执行完毕后 会清空所有的微任务
                    
                    宏任务队列中的script任务在执行时会将所有的微任务队列中的任务都执行完毕后才会执行宏任务队列中的任务
                    微任务队列中的任务执行时,如果又产生了微任务,会将新产生的微任务添加到微任务队列的末尾,所以微任务队列中的任务执行顺序是先进先出,后产生的微任务会先执行
                    宏任务队列中的任务执行时,如果又产生了宏任务,会将新产生的宏任务添加到宏任务队
         4.队列：浏览器默认有多个宏任务队列 我们只关心 event loop中的调用的逻辑  所以 我们通常会说 有一个宏任务队列 
                    微任务是在执行宏任务的时候 就会产生一个微任务队列

                    宏任务:[任务1，任务2]
                    任务1 -> [微任务1，微任务2]

        requestAnimationFrame:浏览器在下一次重绘之前执行回调函数 
        (requestAnimationFrame UI渲染  requestIdleCallback:) 网上说是宏任务  (和浏览器渲染相关，称为钩子)



        除了微任务  都是宏任务
           微任务:queueMicrotask(只在浏览器中有)  Promise.then  process.nextTick(只在node中有)  MutationObserver(只在浏览器中有)

        执行流程
            浏览器会提供一个单独的宏任务队列  默认情况下 所有主线程执行的任务就是一个宏任务
            script(脚本执行)  执行这个脚本之后 会产生宏任务和微任务 微任务会放到微任务队列中  宏任务会放到宏任务队列中 
               等待脚本执行完毕  会清空所有的微任务  在拿出下一个宏任务 继续执行
               每次执行一个宏任务 ->(清空本次产生的所有微任务) -> 可能要渲染 16.6的延迟  -> 拿出下一个宏任务执行
 */


// 执行顺序就是 先执行宏任务 在执行宏任务里的微任务 最后执行宏任务里的宏任务
// setTimeout1
// promise1
// promise2
// promise3
// setTimeout
setTimeout(() => {// 宏任务
    console.log('setTimeout1');
    setTimeout(() => {// 宏任务
        console.log('setTimeout');
    });
    Promise.resolve().then(() => {// 微任务
        console.log('promise1');
    }),
        Promise.resolve().then(() => {// 微任务
            console.log('promise2');
        }),
        Promise.resolve().then(() => {// 微任务
            console.log('promise3');
        })
})