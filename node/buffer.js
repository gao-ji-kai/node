// 为什么需要buffer
// Buffer是node中处理二进制的对象 展现形式是16进制(进制转化) 就是为了js在node中运行时 可以处理二进制数据 (可以直接处理)
// Blob (不能直接进行文件的处理) ArrayBuffer (不能直接操作二进制数据)

// 进制之间的关系  可以通过不同的方式表现相同的内容

// 进制如何转化的

// 二进制 以0b开头

// console.log(parseInt('010101', 2));

// // 可以转换成其他任意进制
// console.log((100).toString(16));

// 面试题 0.1 + 0.2 为什么不等于0.3  // 进制转化导致的  需要将0.1放到内存中
// 小数转整数 采用的方式是乘二取整数

// 0.1
// 0.1*2=0.2   0
// 0.2*2=0.4   0
// 0.4*2=0.8   0
// 0.8*2= 1.6  1
// 0.6*2=1.2   1
//console.log(0.1 + 0.2);
//console.log((0.1).toString(2));// 0.0001100110011001100110011001100110011001100110011001101
//console.log((0.2).toString(2));// 0.001100110011001100110011001100110011001100110011001101


//  编码  utf8 gb2312字体  unicode ascii(我们node默认 只支持utf8)

// 最早采用的编码是ascii  字节 -> 一个字节由八个位组成 一个字节最大是255  0-255  0-11111111
// gb2312 简体中文 两个字节表示一个汉字  一个字节最大是255  两个字节最大是65535  0-65535  0-1111111111111111
// gbk 扩展字体 支持日语、韩语
// unicode 万国码  将所有的符号都统一管理
// utf8  unicode的实现方式  -> 可变字节  一个字节到四个字节  0-111

// base64(传输问题)  基于转换规则来编码的
// 64? 每个字节不得大于64   缺点：会比原来的内容大  优点：可以传输二进制文件
console.log(Buffer.from('凯'));//<Buffer e5 87 af> 相当于 0xe5 0x87 0xaf 转成二进制就是  11100101 10000111 10101111
// 将三个字节 转成四个字节  111001 011000 011110 101111
// 特定的编码规则  0-63  64个字符
console.log(parseInt('00111001', '2'));
console.log(parseInt('00011000', '2'));
console.log(parseInt('00011110', '2'));
console.log(parseInt('00101111', '2'));
// 57 24 30 47

let str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
str += str.toLowerCase();
str += '0123456789+/';
console.log(str[57] + str[24] + str[30] + str[47]);// 5Yev 凯的base64编码

